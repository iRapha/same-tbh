#!/usr/bin/env python3
import argparse
import json
import sys
import os

F_NAME = os.path.join(os.path.join(os.path.expanduser('~'), '.same'))


def load(macro=None, all_macros=False):
    """Load history from ~/.same"""
    if macro is None: macro = 'dude'
    try:
        with open(F_NAME, 'r') as f:
            hist = json.loads(f.read())
            if all_macros:
                return hist
            elif macro not in hist:
                return []
            else:
                return hist[macro]
    except FileNotFoundError:
        return {}

def execute(commands):
    """Execute a list of bash commands."""
    if not commands: 
        print('nothing to same')
        return

    for inp in commands:
        print('same $ ' + inp)
        os.system(inp)

    print('gottem')

def record():
    """Record a list of bash command."""
    hist = []
    inp = input('tbh (recording) $ ')

    while not inp == 'donezo':
        os.system(inp)
        hist.append(inp)
        inp = input('tbh (recording) $ ')

    return hist

def save(commands, macro=None):
    """Save commands to ~/.same"""
    if macro is None: macro = 'dude'
    if not commands: return

    hist = load(all_macros=True)
    hist[macro] = commands

    with open(F_NAME, 'w') as f:
        f.write(json.dumps(hist))
    
    print('gottem')

def delete(macro=None):
    """Deletes a macro from ~/.same"""
    hist = load(all_macros=True)
    
    if macro is None: macro = 'dude'
    if macro not in hist:
        print('macro not found: ' + macro)
        return

    del hist[macro]

    with open(F_NAME, 'w') as f:
        f.write(json.dumps(hist))

    print(macro + ' got rekt')

def find(macro=None):
    """Finds and lists macro names, or a specified macro"""
    hist = load(all_macros=True)

    if macro is None:
        if len(hist) == 0:
            print('no macros saved')
        else:
            print('macros: ' + ', '.join(hist.keys()))
    elif macro not in hist:
        print('macro not found: ' + macro)
    else:
        print(macro + ': ' + str(hist[macro]))

def parse_args():
    parser = argparse.ArgumentParser(description="Record and execute bash macros.")
    subparsers = parser.add_subparsers(help="sucommand help", dest='command')

    default_parser = subparsers.add_parser('record',
            description="Record series of bash commands",
            help='(DEFAULT) record help')
    default_parser.add_argument('macro', help='The macro to modify', nargs='?')

    fuk_parser = subparsers.add_parser('fuk',
            description="Delete a macro",
            help='fuk help')
    fuk_parser.add_argument('macro', help='The macro to modify', nargs='?')

    same_parser = subparsers.add_parser('same',
            description="Execute a saved macro",
            help='same help')
    same_parser.add_argument('macro', help='The macro to modify', nargs='?')
    
    wtf_parser = subparsers.add_parser('wtf',
            description="Find macro names or definitions",
            help='wtf help')
    wtf_parser.add_argument('macro', help='The macro to modify', nargs='?')

    if len(sys.argv) == 1 or sys.argv[1] not in ['record', 'fuk', 'same', 'wtf', '-h', '--help']:
        return parser.parse_args(['record'] + sys.argv[1:])
    else:
        return parser.parse_args()


if __name__ == '__main__':
    args = parse_args()

    if args.command == 'record':
        save(record(), macro=args.macro)
    elif args.command == 'same':
        execute(load(macro=args.macro))
    elif args.command == 'fuk':
        delete(args.macro)
    elif args.command == 'wtf':
        find(args.macro)
    else:
        parser.print_help()
